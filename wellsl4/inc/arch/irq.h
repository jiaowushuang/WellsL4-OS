/*
 * Copyright (c) 2015 Intel corporation
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @file
 * @brief Public interface for configuring interrupts
 */
#ifndef ARCH_IRQ_H_
#define ARCH_IRQ_H_

#ifndef _ASMLANGUAGE
/* Pull in the arch-specific implementations */
#include <types_def.h>
#include <arch/cpu.h>
#include <device.h>
#include <toolchain.h>

#ifdef __cplusplus
extern "C" {
#endif

/* irq table size */
#define IRQ_TABLE_SIZE (CONFIG_NUM_IRQS - CONFIG_GEN_IRQ_START_VECTOR)

/*
 * Note the order: arg first, then ISR. This allows a table entry to be
 * loaded arg -> r0, isr -> r3 in isr_wrapper with one ldmia instruction,
 * on ARM Cortex-M (Thumb2).
 */
struct isr_table_entry {
	void *arg;
	void (*isr)(void *);
};

/* There is an additional member at the end populated by the linker script
 * which indicates the number of interrupts specified
 */
struct isr_list_header {
	u32_t table_size;
	u32_t offset;
};

/*
* Data structure created in a special binary .intlist section for each
* configured interrupt. gen_irq_tables.py pulls this out of the binary and
* uses it to create the IRQ vector table and the sw_isr_table.
*
* More discussion in include/linker/intlist.ld
*/
struct isr_list {
  /** IRQ line number */
  s32_t irq;
  /** Flags for this IRQ, see ISR_FLAG_* definitions */
  s32_t flag;
  /** ISR to call */
  void *func;
  /** Parameter for non-direct IRQs */
  void *param;
};

/** This interrupt gets put directly in the vector table */
enum isr_flag {
  isr_dync_isr = 0,
  isr_direct_isr = BIT(0),
};

/**
 * @brief Lock interrupts.
 * @def irq_lock()
 *
 * This routine disables all interrupts on the CPU. It returns an unsigned
 * integer "lock-out key", which is an architecture-dependent indicator of
 * whether interrupts were locked prior to the call. The lock-out key must be
 * passed to irq_unlock() to re-enable interrupts.
 *
 * This routine can be called recursively, as long as the caller keeps track
 * of each lock-out key that is generated. Interrupts are re-enabled by
 * passing each of the keys to irq_unlock() in the reverse order they were
 * acquired. (That is, each call to irq_lock() must be balanced by
 * a corresponding call to irq_unlock().)
 *
 * @note
 * This routine can be called by ISRs or by record_threads. If it is called by a
 * thread, the interrupt lock is thread-specific; this means that interrupts
 * remain disabled only while the thread is running. If the thread performs an
 * operation that allows another thread to run (for example, giving a semaphore
 * or sleeping for N milliseconds), the interrupt lock no longer applies and
 * interrupts may be re-enabled while other processing occurs. When the thread
 * once again becomes the _current_thread thread, the kernel re-establishes its
 * interrupt lock; this ensures the thread won't be interrupted until it has
 * explicitly released the interrupt lock it established.
 *
 * @warning
 * The lock-out key should never be used to manually re-enable interrupts
 * or to inspect or manipulate the contents of the CPU's interrupt bits.
 *
 * @return An architecture-dependent lock-out key representing the
 *         "interrupt disable state" prior to the call.
 */
#if defined(CONFIG_SMP) 
extern word_t smp_global_lock(void);
#define irq_lock() smp_global_lock()
#else
#define irq_lock() arch_irq_lock()
#endif

/**
 * @brief Unlock interrupts.
 * @def irq_unlock()
 *
 * This routine reverses the effect of a previous call to irq_lock() using
 * the associated lock-out key. The caller must call the routine once for
 * each time it called irq_lock(), supplying the keys in the reverse order
 * they were acquired, before interrupts are enabled.
 *
 * @note Can be called by ISRs.
 *
 * @param key Lock-out key generated by irq_lock().
 *
 * @return N/A
 */
#if defined(CONFIG_SMP) 
extern void smp_global_unlock(word_t key);
#define irq_unlock(key) smp_global_unlock(key)
#else
#define irq_unlock(key) arch_irq_unlock(key)
#endif

/**
 * @brief Enable an IRQ.
 *
 * This routine enables interrupts from source @a irq.
 *
 * @param irq IRQ line.
 *
 * @return N/A
 */
#define irq_enable(irq) arch_irq_enable(irq)

/**
 * @brief Disable an IRQ.
 *
 * This routine disables interrupts from source @a irq.
 *
 * @param irq IRQ line.
 *
 * @return N/A
 */
#define irq_disable(irq) arch_irq_disable(irq)

/**
 * @brief Get IRQ enable state.
 *
 * This routine indicates if interrupts from source @a irq are enabled.
 *
 * @param irq IRQ line.
 *
 * @return interrupt enable state, true or false
 */
#define irq_is_enabled(irq) arch_irq_is_enabled(irq)
#define irq_is_pending() arch_is_irq_pending()

#ifdef CONFIG_DYNAMIC_INTERRUPTS
extern struct isr_table_entry sw_isr_table[];
static FORCE_INLINE void isr_install(word_t irq, void (*routine)(void *), void *param)
{
	word_t table_idx = irq - CONFIG_GEN_IRQ_START_VECTOR;

	if (irq_is_enabled(irq))
	{
		/* If dynamic IRQs are enabled, then the sw_isr_table is in RAM and
		 * can be modified
		 */
		sw_isr_table[table_idx].arg = param;
		sw_isr_table[table_idx].isr = routine;
	}
}
#endif


#if defined(CONFIG_IRQ_OFFLOAD) 
typedef void (*irq_offload_routine_t)(void *);

/**
 * @brief Run a function in interrupt context
 *
 * This function synchronously runs the provided function in interrupt
 * context, passing in the supplied parameter. Useful for test code
 * which needs to show that kernel k_objects work correctly in interrupt
 * context.
 *
 * @param routine The function to run
 * @param parameter Argument to pass to the function when it is run as an
 * interrupt
 */
void thread_irq_offload(irq_offload_routine_t routine, void *parameter);
#endif

#ifdef CONFIG_IRQ_NEXT_LEVEL
/**
 * @cond INTERNAL_HIDDEN
 *
 * These are for internal use only, so skip these in
 * public documentation.
 */
typedef void (*irq_next_level_func_t)(struct device *dev, word_t irq);
typedef word_t (*irq_next_level_get_state_t)(struct device *dev);
typedef void (*irq_next_level_priority_t)(struct device *dev, word_t irq, 
	word_t prio, u32_t flags);
typedef int (*irq_next_level_get_line_state_t)(struct device *dev,
	word_t irq);

struct irq_next_level_api {
	irq_next_level_func_t intr_enable;
	irq_next_level_func_t intr_disable;
	irq_next_level_get_state_t intr_get_state;
	irq_next_level_priority_t intr_set_priority;
	irq_next_level_get_line_state_t intr_get_line_state;
};

/**
 * @brief Enable an IRQ in the next level.
 *
 * This routine enables interrupts present in the interrupt controller.
 *
 * @param dev Pointer to the device structure for the driver instance.
 * @param irq IRQ to be enabled.
 *
 * @return N/A
 */
static FORCE_INLINE void irq_enable_next_level(struct device *dev, u32_t irq)
{
	const struct irq_next_level_api *api =
		(const struct irq_next_level_api *)dev->driver_api;

	api->intr_enable(dev, irq);
}

/**
 * @brief Disable an IRQ in the next level.
 *
 * This routine disables interrupts present in the interrupt controller.
 *
 * @param dev Pointer to the device structure for the driver instance.
 * @param irq IRQ to be disabled.
 *
 * @return N/A
 */
static FORCE_INLINE void irq_disable_next_level(struct device *dev, u32_t irq)
{
	const struct irq_next_level_api *api =
		(const struct irq_next_level_api *)dev->driver_api;

	api->intr_disable(dev, irq);
}

/**
 * @brief Get IRQ enable state.
 *
 * This routine indicates if any interrupts are enabled in the interrupt
 * controller.
 *
 * @param dev Pointer to the device structure for the driver instance.
 *
 * @return interrupt enable state, true or false
 */
static FORCE_INLINE word_t irq_is_enabled_next_level(struct device *dev)
{
	const struct irq_next_level_api *api =
		(const struct irq_next_level_api *)dev->driver_api;

	return api->intr_get_state(dev);
}

/**
 * @brief Set IRQ priority.
 *
 * This routine indicates if any interrupts are enabled in the interrupt
 * controller.
 *
 * @param dev Pointer to the device structure for the driver instance.
 * @param irq IRQ to be disabled.
 * @param prio priority for irq in the interrupt controller.
 * @param flags controller specific flags.
 *
 * @return N/A
 */
static FORCE_INLINE void irq_set_priority_next_level(struct device *dev, u32_t irq,
		u32_t prio, u32_t flags)
{
	const struct irq_next_level_api *api =
		(const struct irq_next_level_api *)dev->driver_api;

	if (api->intr_set_priority)
		api->intr_set_priority(dev, irq, prio, flags);
}

/**
 * @brief Get IRQ line enable state.
 *
 * Query if a particular IRQ line is enabled.
 *
 * @param dev Pointer to the device structure for the driver instance.
 * @param irq IRQ line to be queried.
 *
 * @return interrupt enable state, true or false
 */
static FORCE_INLINE word_t irq_line_is_enabled_next_level(struct device *dev,
							  word_t irq)
{
	const struct irq_next_level_api *api =
		(const struct irq_next_level_api *)dev->driver_api;

	return api->intr_get_line_state(dev, irq);
}
#endif

#define ISR_NAME(x, y) __isr_ ## x ## _irq_ ## y

/* Create an instance of struct _isr_list which gets put in the .intList
* section. This gets consumed by gen_isr_tables.py which creates the vector
* and/or SW ISR tables.
*/
#define ISR_DEFINE(irq, flag, func, param) \
	  static DECL_ALIGN(struct isr_list) GENERIC_SECTION(.intList) \
	  __used ISR_NAME(func, __COUNTER__) = \
	  {irq, flag, &func, (void *)param}


/**
* @brief Initialize an interrupt handler.
*
* This routine initializes an interrupt handler for an IRQ. The IRQ must be
* subsequently enabled before the interrupt handler begins servicing
* interrupts.
*
* @warning
* Although this routine is invoked at run-time, all of its arguments must be
* computable by the compiler at build time.
*
* @param irq_p IRQ line number.
* @param sched_prior_p Interrupt sched_prior.
* @param isr_p Address of interrupt service routine.
* @param isr_param_p Parameter passed to interrupt service routine.
* @param flags_p Architecture-specific IRQ configuration flag..
*
* @return Interrupt vector assigned to this interrupt.
*/
#define IRQ_DYNC_CONNECT(irq_p, sched_prior_p, isr_p, isr_param_p, flags_p) \
  ARCH_IRQ_DYNC_CONNECT(irq_p, sched_prior_p, isr_p, isr_param_p, flags_p)


/**
* Configure a dynamic interrupt.
*
* Use this instead of IRQ_RECONNECT() if arguments cannot be known at build time.
*
* @param irq IRQ line number
* @param sched_prior Interrupt sched_prior
* @param routine Interrupt service routine
* @param parameter ISR parameter
* @param flag Arch-specific IRQ configuration flag
*
* @return The vector assigned to this interrupt
*/

#define IRQ_DYNC_RECONNECT(irq_p, sched_prior_p, isr_p, isr_param_p, flags_p) \
  arch_irq_connect_dynamic(irq_p, sched_prior_p, isr_p, isr_param_p, flags_p);

/**
* @brief Initialize a 'direct' interrupt handler.
*
* This routine initializes an interrupt handler for an IRQ. The IRQ must be
* subsequently enabled via irq_enable() before the interrupt handler begins
* servicing interrupts.
*
* These ISRs are designed for performance-critical interrupt handling and do
* not go through common interrupt handling code. They must be implemented in
* such a way that it is safe to put them directly in the vector table.  For
* ISRs written in C, The ISR_DIRECT_DECLARE() macro will do this
* automatically. For ISRs written in assembly it is entirely up to the
* developer to ensure that the right steps are taken.
*
* This type of interrupt currently has a few limitations compared to normal
* WellL4 interrupts:
* - No parameters are passed to the ISR.
* - No stack switch is done, the ISR will run on the interrupted context's
*   stack, unless the architecture automatically does the stack switch in HW.
* - Interrupt locking state is unchanged from how the HW sets it when the ISR
*   runs. On arches that enter ISRs with interrupts locked, they will remain
*   locked.
* - Scheduling decisions are now optional, controlled by the return value of
*   ISRs implemented with the ISR_DIRECT_DECLARE() macro
* - The call into the OS to exit power management idle state is now optional.
*   Normal interrupts always do this before the ISR is run, but when it runs
*   is now controlled by the placement of a ISR_DIRECT_PM() macro, or omitted
*   entirely.
*
* @warning
* Although this routine is invoked at run-time, all of its arguments must be
* computable by the compiler at build time.
*
* @param irq_p IRQ line number.
* @param sched_prior_p Interrupt sched_prior.
* @param isr_p Address of interrupt service routine.
* @param flags_p Architecture-specific IRQ configuration flag.
*
* @return Interrupt vector assigned to this interrupt.
*/
#define IRQ_DIRECT_CONNECT(irq_p, sched_prior_p, isr_p, flags_p) \
  ARCH_IRQ_DIRECT_CONNECT(irq_p, sched_prior_p, isr_p, flags_p)

/**
* @brief Common tasks before executing the body of an ISR
*
* This macro must be at the beginning of all direct interrupts and performs
* minimal architecture-specific tasks before the ISR itself can run. It takes
* no arguments and has no return value.
*/
#define ISR_DIRECT_HEADER() ARCH_ISR_DIRECT_HEADER()

/**
* @brief Common tasks before exiting the body of an ISR
*
* This macro must be at the end of all direct interrupts and performs
* minimal architecture-specific tasks like EOI. It has no return value.
*
* In a normal interrupt, a check is done at end of interrupt to invoke
* swap_thread() logic if the _current_thread thread is preemptible and there is another
* thread ready to run in the kernel's ready queue cache. This is now optional
* and controlled by the check_reschedule argument. If unsure, set to nonzero.
* On systems that do stack switching and int_nest_count interrupt tracking in software,
* swap_thread() should only be called if this was a non-int_nest_count interrupt.
*
* @param check_reschedule If nonzero, additionally invoke scheduling logic
*/
#define ISR_DIRECT_FOOTER(check_reschedule) \
  ARCH_ISR_DIRECT_FOOTER(check_reschedule)

/**
* @brief Perform power management idle exit logic
*
* This macro may optionally be invoked somewhere in between IRQ_DIRECT_HEADER()
* and IRQ_DIRECT_FOOTER() invocations. It performs tasks necessary to
* exit power management idle state. It takes no parameters and returns no
* arguments. It may be omitted, but be careful!
*/
#define ISR_DIRECT_PM() ARCH_ISR_DIRECT_PM()

/**
* @brief Helper macro to declare a direct interrupt service routine.
*
* This will declare the function in a proper way and automatically include
* the ISR_DIRECT_FOOTER() and ISR_DIRECT_HEADER() macros. The function should
* return nonzero status if a scheduling decision should potentially be made.
* See ISR_DIRECT_FOOTER() for more details on the scheduling decision.
*
* For architectures that support 'regular' and 'fast' interrupt types, where
* these interrupt types require different assembly language handling of
* registers by the ISR, this will always generate code for the 'fast'
* interrupt type.
*
* Example usage:
*
* ISR_DIRECT_DECLARE(my_isr)
* {
*  bool done = do_stuff();
*  ISR_DIRECT_PM(); <-- done after do_stuff() due to latency concerns
*  if (!done) {
*	  return 0;  <-- Don't bother checking if we have to swap_thread()
*  }
*  k_sem_give(some_sem);
*  return 1;
* }
*
* @param name symbol name of the ISR
*/
#define ISR_DIRECT_DECLARE(name) ARCH_ISR_DIRECT_DECLARE(name)

#ifdef __cplusplus
}
#endif

#endif
#endif
